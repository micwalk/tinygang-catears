import bpy
import math
import csv
import re
from mathutils import Vector

# No way to programatically access what collection is selected??
# Fine just use active


# Get the active collection
active_collection = bpy.context.view_layer.active_layer_collection.collection 
if active_collection is None:
    print("No active collection. bailing")
    raise ValueError("Error: No active collection.")
    
#Calculate scale factor for printing. Doesn't support anything but mm and m
scale_factor =  bpy.context.scene.unit_settings.scale_length
if bpy.context.scene.unit_settings.length_unit == 'MILLIMETERS':
    scale_factor = scale_factor * 1000

ear_left  = bpy.data.objects.get("LeftEarCenter")
ear_right = bpy.data.objects.get("RightEarCenter")


def parse_object_name(name):
    match = re.match(r"(.*)\.(\d+)", name)
    if match:
        tag = match.group(1)
        number = int(match.group(2))
        return tag, number
    else:
        raise ValueError("Error: Invalid object name format.")
        
with open("E:\\Data\\My Documents\\Blender\\LedSpatialBlender.cpp", "w", newline="") as cppfile:
    with open("E:\\Data\\My Documents\\Blender\\CatEarLedPositions.csv", "w", newline="") as csvfile:
        # Create a CSV writer
        csvwriter = csv.writer(csvfile)

        #Prepare cpp header
        cppfile.write("""
//Note: This file has been automatically generated by the blender "Print Collection" Script. Do not modify.
#include "config/UserConfig.h"
#include "SpatialPatterns/LedPosition.h"
""")

        cppfile.write("// left ear center: {ear_left_pos.x}, {ear_left_pos.z}, {math.degrees(math.atan2(ear_left_pos.x, ear_left_pos.z))}, {ear_left_pos.length]}\n")
        cppfile.write("// right ear center: {ear_right_pos.x}, {ear_right_pos.z}, {math.degrees(math.atan2(ear_right_pos.x, ear_right_pos.z))}, {ear_right_pos.length]}\n")
        cppfile.write("LedPosition LED_POSITIONS[NUM_LEDS] = {\n")

        # Write the header row
        print("id,name,x,y,center.angle,center.radius,left.angle,left.radius,right.angle,right.radius")
        csvwriter.writerow(["id", "name", "x", "y", "center.angle", "center.radius", "left.angle", "left.radius", "right.angle", "right.radius"])

        #Debug the left/right locations
        
        ear_left_pos = scale_factor * ear_left.matrix_world.to_translation()
        ear_right_pos = scale_factor * ear_right.matrix_world.to_translation()
        
        csvwriter.writerow([-1,"LeftEarCenter", ear_left_pos.x, ear_left_pos.z, math.degrees(math.atan2(ear_left_pos.x, ear_left_pos.z)), ear_left_pos.length])
        csvwriter.writerow([-2,"RightEarCenter", ear_right_pos.x, ear_right_pos.z, math.degrees(math.atan2(ear_right_pos.x, ear_right_pos.z)), ear_right_pos.length])

        
        
        wire_map_left  = [16, 17, 18, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 0, 4, 3, 6, 5, 2]
        wire_map_right = [35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 37, 36, 20, 19, 23, 24, 21, 22, 25]
        name_map = {
            "RingLedsLeft"  : "LedSection::EAR_LEFT",
            "RingLedsRight" : "LedSection::EAR_RIGHT",
            "StipLeds"      : "LedSection::BAND" }
        
        led_id = 0    
        #Iterate over collection elements
        for part in active_collection.all_objects:
            # Get the object's mesh data
            mesh = part.data
            
            # Convert the local space coordinates to world space coordinates
            world_coords = [part.matrix_world @ v.co for v in mesh.vertices]
            # Sum of world_coords
            sum_coord = Vector((0, 0, 0))
            sum_coord = sum([v for v in world_coords], sum_coord)
            # Calculate the median point
            median_point = scale_factor * sum_coord / len(world_coords)
            
            #Calculate polar
            
            #From Center
            center_dist = median_point.length
            center_angle = math.degrees(math.atan2(median_point.x, median_point.z))
            
            # From Left Ear
            leftVec = median_point - ear_left_pos
            # Get the polar coordinates in the X,Z plane
            left_dist = leftVec.length
            left_angle = math.degrees(math.atan2(leftVec.x, leftVec.z))

            # From Right Ear
            rightVec = median_point - ear_right_pos
            # Get the polar coordinates in the X,Z plane
            right_dist = rightVec.length
            right_angle = math.degrees(math.atan2(rightVec.x, rightVec.z))
            
            ledType, ledSectionNum = parse_object_name(part.name)

            #determine map to wire led position
            wire_id = led_id;
            if ledType == "RingLedsRight":
                wire_id = wire_map_right[ledSectionNum - 1]
            elif ledType == "RingLedsLeft":
                wire_id = wire_map_left[ledSectionNum - 1]
                            
            print(f"{led_id},{part.name},{median_point.x},{median_point.z},{center_angle},{center_dist},{left_angle},{left_dist},{right_angle},{right_dist}")
            csvwriter.writerow([led_id, part.name, median_point.x, median_point.z, center_angle, center_dist, left_angle, left_dist, right_angle, right_dist])
            
            if led_id > 0:
                cppfile.write(", \n")
                
            cppfile.write(f"\t{{ {led_id}, {wire_id}, {name_map[ledType]}, {ledSectionNum-1}")
            cppfile.write(f", {{ {median_point.x},{median_point.z} }}")
            cppfile.write(f", {{ {center_angle},{center_dist} }} ")
            cppfile.write(f", {{ {left_angle},{left_dist} }}")
            cppfile.write(f", {{ {right_angle},{right_dist} }} }}");
            led_id = led_id + 1
        
        #cpp footer
        cppfile.write("\n};\n")
        cppfile.write(f"//Total LEDs: There are {led_id} total LEDS. \n")
        cppfile.write("//Check for correct total LED count\nstatic_assert(\n")
        cppfile.write(f'\tNUM_LEDS == {led_id},\n\t"NUM_LEDS doesnt match blender export LED count of {led_id}");\n')

    
    
